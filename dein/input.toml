# SKK {{{
[[plugins]]
repo = 'tyru/eskk.vim'
on_map = {i = '<plug>(eskk'}
hook_add = '''
	imap <c-j> <plug>(eskk:toggle)
	let g:eskk#directory = expand('$DATA/eskk')
'''
hook_source = '''
	" 辞書
	let g:eskk#dictionary = {'encoding': 'utf-8', 'sorted': 0, 'path': expand(g:eskk#directory . '/SKK-JISYO.eskk')}
	if filereadable(expand('$DATA/skk/SKK-JISYO.L'))
		let g:eskk#large_dictionary = {'encoding': 'utf-8', 'sorted': 1, 'path': expand('$DATA/skk/SKK-JISYO.L')}
	endif
	let g:eskk#server = {'host': 'localhost', 'port': 1178}

	" マーカー
	let g:eskk#marker_henkan = '<>'
	let g:eskk#marker_henkan_select = '>>'

	" 指定した文字数が入力されるまで補完しない
	let g:eskk#start_completion_length = 2

	" <Tab> キーで次の候補を選択
	let g:eskk#tab_select_completion = v:true

	" 候補が1つの場合確定
	let g:eskk#kakutei_when_unique_candidate = v:true

	" TODO: 整理
	let g:eskk#egg_like_newline = v:true
	let g:eskk#egg_like_newline_completion = v:true
	let g:eskk#keep_state = v:false
	let g:eskk#show_annotation = v:true

	autocmd MyAutoCmd User eskk-initialize-post EskkMap -remap jj <ESC>
'''
# }}}

[[plugins]]
repo = 'Shougo/context_filetype.vim'

[[plugins]]
repo = 'Shougo/deoplete.nvim'
depends = 'context_filetype.vim'
on_event = 'InsertEnter'
hook_add = '''
	" 補完のオプション
	set completeopt=menu,menuone,noinsert,noselect
	" 補完の表示項目数
	set pumheight=10
	" ins-completion-menu 関連のメッセージを表示しない
	set shortmess+=c

	set isfname-==
'''
hook_source = '''
	" <TAB>: completion.
	inoremap <silent><expr> <TAB> pumvisible() ? "\<C-n>" : <SID>check_back_space() ? "\<TAB>" : deoplete#manual_complete()
	function! s:check_back_space() abort
		let col = col('.') - 1
		return !col || getline('.')[col - 1]  =~# '\s'
	endfunction

	" <S-TAB>: completion back.
	inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

	" <C-g>:
	inoremap <expr><C-g> deoplete#refresh()

	" <CR>: close popup and save indent.
	inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
	function! s:my_cr_function() abort
		return pumvisible() ? deoplete#close_popup()."\<CR>" : "\<CR>"
	endfunction

	call deoplete#custom#source('nextword', 'filetypes',
      \ ['markdown', 'help', 'gitcommit', 'text'])

	" converters
	call deoplete#custom#source('_', 'converters', [
	\	'converter_remove_paren',
	\ 	'converter_remove_overlap',
	\ 	'matcher_length',
	\ 	'converter_truncate_abbr',
	\ 	'converter_truncate_menu',
	\ 	'converter_auto_delimiter',
	\ ])

	call deoplete#custom#source('_', 'matchers', ['matcher_fuzzy', 'matcher_length'])
	"call deoplete#custom#source('eskk', 'matchers', [])

	call deoplete#custom#option('ignore_sources', {'_': ['around', 'buffer', 'tag', 'dictionary']})

	call deoplete#custom#option({
			\ 'auto_refresh_delay': 10,
			\ 'camel_case': v:true,
			\ 'skip_multibyte': v:true,
			\ 'prev_completion_mode': 'none',
			\ 'auto_preview': v:true,
			\ })

	call deoplete#enable()
'''

# snipes {{{
[[plugins]]
repo = 'Shougo/deoppet.nvim'
depends = ['neosnippet-snippets', 'context_filetype.vim']
on_event = 'InsertEnter'
hook_source = '''
	imap <C-k>  <Plug>(deoppet_expand)
	imap <expr> L  deoppet#expandable() ? "\<Plug>(deoppet_expand)" : ''
	imap <C-f>  <Plug>(deoppet_jump_forward)
	imap <C-b>  <Plug>(deoppet_jump_backward)
	xmap <C-l>  <Plug>(deoppet_select_text)
	xmap <C-x>  <Plug>(deoppet_cut_text)

	call deoppet#initialize()
	call deoppet#custom#option('snippets',
		\ map(globpath(&runtimepath, 'neosnippets', 1, 1),
		\     "{ 'path': v:val }"))
'''

[[plugins]]
repo = 'Shougo/neosnippet-snippets'
# }}}
